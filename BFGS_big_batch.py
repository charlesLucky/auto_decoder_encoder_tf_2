# -*- coding: utf-8 -*-
# Implementing a Genetic Algorithm
# -------------------------------
#
# Genetic Algorithm Optimization in TensorFlow
#
# We are going to implement a genetic algorithm
#   to optimize to a ground truth array.  The ground
#   truth will be an array of 50 floating point
#   numbers which are generated by:
#   f(x)=sin(2*pi*x/50) where 0<x<50
#
# Each individual will be an array of 50 floating
#   point numbers and the fitness will be the average
#   mean squared error from the ground truth.
#
# We will use TensorFlow's update function to run the
#   different parts of the genetic algorithm.
#
# While TensorFlow isn't really the best for GA's,
#   this example shows that we can implement different
#   procedural algorithms with TensorFlow operations.
__author__ = 'xingbo, it is based on inital version of sidharthgoyal'
import math
from random import *
import random
import numpy
import os
import numpy as np
# import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.python.framework import ops
import tqdm
from PIL import Image

os.environ['CUDA_VISIBLE_DEVICES'] = '2,5'
# os.environ['TF_CPP_MIN_LOG_LEVEL']='3'# 只显示 Error
import logging
logging.disable(30)# for disable the warnning in gradient tape
from skimage import io
from skimage.transform import rescale, resize, downscale_local_mean
from ModelZoo import loadStyleGAN2Model, loadArcfaceModel
from stylegan2.utils import postprocess_images
import time
##here we load generator
from tf_utils import allow_memory_growth

import numpy as np
from scipy.optimize import minimize


# allow_memory_growth()
with tf.device('/gpu:0'):
    arcfacemodel = loadArcfaceModel()

with tf.device('/gpu:1'):
    g_clone = loadStyleGAN2Model()

# Create ground truth
# truth = np.sin(2 * np.pi * (np.arange(features, dtype=np.float32)) / features)
input_dir = "data/imgs"
input_img_paths = sorted(
    [
        os.path.join(input_dir, fname)
        for fname in os.listdir(input_dir)
        if fname.endswith(".png")
    ]
)

imgs =[]
for j, path in enumerate(input_img_paths):
    img = io.imread(path)
    img = resize(img,
           (112,112),
           anti_aliasing=True)
    imgs.append(np.array(img))
imgs = np.array(imgs)
feat_gt_orig = arcfacemodel(imgs/255.0).numpy()
feat_gt = feat_gt_orig[0]


the_img_savepath = 'data/BFGS'


def distance(coords1, coords2):
    """ Calculates the euclidean distance between 2 lists of coordinates. """
    # print('coords1',coords1)
    # print('coords2',coords2)
    return numpy.sqrt(numpy.sum((coords1 - coords2) ** 2))

def rosen(x):
    """The Rosenbrock function"""
    input = np.expand_dims(x,axis=0)
    image_out_g = g_clone([input, []], training=False, truncation_psi=0.5)
    image_out_g = postprocess_images(image_out_g)
    # pay attention to the slice index number
    feature_new= arcfacemodel(
        tf.image.resize(image_out_g, size=(112, 112)) / 255.)
    xt = feature_new.numpy()[0]
    score = np.sqrt(np.sum((feat_gt - xt)**2))
    print('score',score)
    return score


# 初始迭代点
x0 = np.random.rand(512) * 2

res = minimize(rosen, x0, method='BFGS', jac=[],
               options={'disp': True})

print('res',res.x[:10])
print('target:', feat_gt[:10])

